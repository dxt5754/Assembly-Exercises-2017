


ARM Macro Assembler    Page 1 Secure String I/O and Number Output


    1 00000000                 TTL              Secure String I/O and Number Ou
tput
    2 00000000         ;*******************************************************
                       *********
    3 00000000         ;Uses secure subroutines for serial I/O of strings
    4 00000000         ;and uses a specified program to test them
    5 00000000         ;Name:  Dean Trivisani
    6 00000000         ;Date:  10/3/2017
    7 00000000         ;Class:  CMPE-250
    8 00000000         ;Section:  01L5
    9 00000000         ;-------------------------------------------------------
                       --------
   10 00000000         ;Keil Template for KL46
   11 00000000         ;R. W. Melton
   12 00000000         ;September 25, 2017
   13 00000000         ;*******************************************************
                       *********
   14 00000000         ;Assembler directives
   15 00000000                 THUMB
   17 00000000         ;*******************************************************
                       *********
   18 00000000         ;Include files
   19 00000000                 GET              MKL46Z4.s   ;Included by start.
                                                            s
   21 00000000         ;*******************************************************
                       *********
   22 00000000         ;EQUates
   23 00000000         
   24 00000000         ;-------------------------------------------------------
                       --------
   25 00000000         ;PORTx_PCRn (Port x pin control register n [for pin n])
   26 00000000         ;___->10-08:Pin mux control (select 0 to 8)
   27 00000000         ;Use provided PORT_PCR_MUX_SELECT_2_MASK
   28 00000000         ;-------------------------------------------------------
                       --------
   29 00000000         ;Port A
   31 00000000 01000200 
                       PORT_PCR_SET_PTA1_UART0_RX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   33 00000000 01000200 
                       PORT_PCR_SET_PTA2_UART0_TX
                               EQU              (PORT_PCR_ISF_MASK :OR:       
                             PORT_PCR_MUX_SELECT_2_MASK)
   34 00000000         ;-------------------------------------------------------
                       --------
   35 00000000         ;SIM_SCGC4
   36 00000000         ;1->10:UART0 clock gate control (enabled)
   37 00000000         ;Use provided SIM_SCGC4_UART0_MASK
   38 00000000         ;-------------------------------------------------------
                       --------
   39 00000000         ;SIM_SCGC5
   40 00000000         ;1->09:Port A clock gate control (enabled)
   41 00000000         ;Use provided SIM_SCGC5_PORTA_MASK
   42 00000000         ;-------------------------------------------------------
                       --------
   43 00000000         ;SIM_SOPT2
   44 00000000         ;01=27-26:UART0SRC=UART0 clock source select
   45 00000000         ;         (PLLFLLSEL determines MCGFLLCLK' or MCGPLLCLK/



ARM Macro Assembler    Page 2 Secure String I/O and Number Output


                       2)
   46 00000000         ; 1=   16:PLLFLLSEL=PLL/FLL clock select (MCGPLLCLK/2)
   48 00000000 04000000 
                       SIM_SOPT2_UART0SRC_MCGPLLCLK
                               EQU              (1 << SIM_SOPT2_UART0SRC_SHIFT)
   50 00000000 04010000 
                       SIM_SOPT2_UART0_MCGPLLCLK_DIV2
                               EQU              (SIM_SOPT2_UART0SRC_MCGPLLCLK :
OR: SIM_SOPT2_PLLFLLSEL_MASK)
   51 00000000         ;-------------------------------------------------------
                       --------
   52 00000000         ;SIM_SOPT5
   53 00000000         ; 0->   16:UART0 open drain enable (disabled)
   54 00000000         ; 0->   02:UART0 receive data select (UART0_RX)
   55 00000000         ;00->01-00:UART0 transmit data select source (UART0_TX)
   59 00000000 00010007 
                       SIM_SOPT5_UART0_EXTERN_MASK_CLEAR
                               EQU              (SIM_SOPT5_UART0ODE_MASK :OR:  
                                SIM_SOPT5_UART0RXSRC_MASK :OR:               
                   SIM_SOPT5_UART0TXSRC_MASK)
   60 00000000         ;-------------------------------------------------------
                       --------
   61 00000000         ;UART0_BDH
   62 00000000         ;    0->  7:LIN break detect IE (disabled)
   63 00000000         ;    0->  6:RxD input active edge IE (disabled)
   64 00000000         ;    0->  5:Stop bit number select (1)
   65 00000000         ;00001->4-0:SBR[12:0] (UART0CLK / [9600 * (OSR + 1)]) 
   66 00000000         ;UART0CLK is MCGPLLCLK/2
   67 00000000         ;MCGPLLCLK is 96 MHz
   68 00000000         ;MCGPLLCLK/2 is 48 MHz
   69 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   70 00000000 00000001 
                       UART0_BDH_9600
                               EQU              0x01
   71 00000000         ;-------------------------------------------------------
                       --------
   72 00000000         ;UART0_BDL
   73 00000000         ;0x38->7-0:SBR[7:0] (UART0CLK / [9600 * (OSR + 1)])
   74 00000000         ;UART0CLK is MCGPLLCLK/2
   75 00000000         ;MCGPLLCLK is 96 MHz
   76 00000000         ;MCGPLLCLK/2 is 48 MHz
   77 00000000         ;SBR = 48 MHz / (9600 * 16) = 312.5 --> 312 = 0x138
   78 00000000 00000038 
                       UART0_BDL_9600
                               EQU              0x38
   79 00000000         ;-------------------------------------------------------
                       --------
   80 00000000         ;UART0_C1
   81 00000000         ;0-->7:LOOPS=loops select (normal)
   82 00000000         ;0-->6:DOZEEN=doze enable (disabled)
   83 00000000         ;0-->5:RSRC=receiver source select (internal--no effect 
                       LOOPS=0)
   84 00000000         ;0-->4:M=9- or 8-bit mode select 
   85 00000000         ;        (1 start, 8 data [lsb first], 1 stop)
   86 00000000         ;0-->3:WAKE=receiver wakeup method select (idle)
   87 00000000         ;0-->2:IDLE=idle line type select (idle begins after sta
                       rt bit)
   88 00000000         ;0-->1:PE=parity enable (disabled)
   89 00000000         ;0-->0:PT=parity type (even parity--no effect PE=0)



ARM Macro Assembler    Page 3 Secure String I/O and Number Output


   90 00000000 00000000 
                       UART0_C1_8N1
                               EQU              0x00
   91 00000000         ;-------------------------------------------------------
                       --------
   92 00000000         ;UART0_C2
   93 00000000         ;0-->7:TIE=transmit IE for TDRE (disabled)
   94 00000000         ;0-->6:TCIE=transmission complete IE for TC (disabled)
   95 00000000         ;0-->5:RIE=receiver IE for RDRF (disabled)
   96 00000000         ;0-->4:ILIE=idle line IE for IDLE (disabled)
   97 00000000         ;1-->3:TE=transmitter enable (enabled)
   98 00000000         ;1-->2:RE=receiver enable (enabled)
   99 00000000         ;0-->1:RWU=receiver wakeup control (normal)
  100 00000000         ;0-->0:SBK=send break (disabled, normal)
  101 00000000 0000000C 
                       UART0_C2_T_R
                               EQU              (UART0_C2_TE_MASK :OR: UART0_C2
_RE_MASK)
  102 00000000         ;-------------------------------------------------------
                       --------
  103 00000000         ;UART0_C3
  104 00000000         ;0-->7:R8T9=9th data bit for receiver (not used M=0)
  105 00000000         ;           10th data bit for transmitter (not used M10=
                       0)
  106 00000000         ;0-->6:R9T8=9th data bit for transmitter (not used M=0)
  107 00000000         ;           10th data bit for receiver (not used M10=0)
  108 00000000         ;0-->5:TXDIR=UART_TX pin direction in single-wire mode
  109 00000000         ;            (no effect LOOPS=0)
  110 00000000         ;0-->4:TXINV=transmit data inversion (not inverted)
  111 00000000         ;0-->3:ORIE=overrun IE for OR (disabled)
  112 00000000         ;0-->2:NEIE=noise error IE for NF (disabled)
  113 00000000         ;0-->1:FEIE=framing error IE for FE (disabled)
  114 00000000         ;0-->0:PEIE=parity error IE for PF (disabled)
  115 00000000 00000000 
                       UART0_C3_NO_TXINV
                               EQU              0x00
  116 00000000         ;-------------------------------------------------------
                       --------
  117 00000000         ;UART0_C4
  118 00000000         ;    0-->  7:MAEN1=match address mode enable 1 (disabled
                       )
  119 00000000         ;    0-->  6:MAEN2=match address mode enable 2 (disabled
                       )
  120 00000000         ;    0-->  5:M10=10-bit mode select (not selected)
  121 00000000         ;01111-->4-0:OSR=over sampling ratio (16)
  122 00000000         ;               = 1 + OSR for 3 <= OSR <= 31
  123 00000000         ;               = 16 for 0 <= OSR <= 2 (invalid values)
  124 00000000 0000000F 
                       UART0_C4_OSR_16
                               EQU              0x0F
  125 00000000 0000000F 
                       UART0_C4_NO_MATCH_OSR_16
                               EQU              UART0_C4_OSR_16
  126 00000000         ;-------------------------------------------------------
                       --------
  127 00000000         ;UART0_C5
  128 00000000         ;  0-->  7:TDMAE=transmitter DMA enable (disabled)
  129 00000000         ;  0-->  6:Reserved; read-only; always 0
  130 00000000         ;  0-->  5:RDMAE=receiver full DMA enable (disabled)



ARM Macro Assembler    Page 4 Secure String I/O and Number Output


  131 00000000         ;000-->4-2:Reserved; read-only; always 0
  132 00000000         ;  0-->  1:BOTHEDGE=both edge sampling (rising edge only
                       )
  133 00000000         ;  0-->  0:RESYNCDIS=resynchronization disable (enabled)
                       
  134 00000000 00000000 
                       UART0_C5_NO_DMA_SSR_SYNC
                               EQU              0x00
  135 00000000         ;-------------------------------------------------------
                       --------
  136 00000000         ;UART0_S1
  137 00000000         ;0-->7:TDRE=transmit data register empty flag; read-only
                       
  138 00000000         ;0-->6:TC=transmission complete flag; read-only
  139 00000000         ;0-->5:RDRF=receive data register full flag; read-only
  140 00000000         ;1-->4:IDLE=idle line flag; write 1 to clear (clear)
  141 00000000         ;1-->3:OR=receiver overrun flag; write 1 to clear (clear
                       )
  142 00000000         ;1-->2:NF=noise flag; write 1 to clear (clear)
  143 00000000         ;1-->1:FE=framing error flag; write 1 to clear (clear)
  144 00000000         ;1-->0:PF=parity error flag; write 1 to clear (clear)
  145 00000000 0000001F 
                       UART0_S1_CLEAR_FLAGS
                               EQU              0x1F
  146 00000000         ;-------------------------------------------------------
                       --------
  147 00000000         ;UART0_S2
  148 00000000         ;1-->7:LBKDIF=LIN break detect interrupt flag (clear)
  149 00000000         ;             write 1 to clear
  150 00000000         ;1-->6:RXEDGIF=RxD pin active edge interrupt flag (clear
                       )
  151 00000000         ;              write 1 to clear
  152 00000000         ;0-->5:(reserved); read-only; always 0
  153 00000000         ;0-->4:RXINV=receive data inversion (disabled)
  154 00000000         ;0-->3:RWUID=receive wake-up idle detect
  155 00000000         ;0-->2:BRK13=break character generation length (10)
  156 00000000         ;0-->1:LBKDE=LIN break detect enable (disabled)
  157 00000000         ;0-->0:RAF=receiver active flag; read-only
  158 00000000 000000C0 
                       UART0_S2_NO_RXINV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
                               EQU              0xC0
  159 00000000         
  160 00000000 0000004F 
                       MAX_STRING
                               EQU              79          ;Max number of stri
                                                            ng characters, incl
                                                            uding null characte
                                                            r
  161 00000000 000003E8 
                       DIV1K   EQU              0x3E8
  162 00000000 00002710 
                       DIV10K  EQU              0x2710
  163 00000000 000186A0 
                       DIV100K EQU              0x186A0
  164 00000000 000F4240 
                       DIV1M   EQU              0xF4240
  165 00000000         
  166 00000000         ;*******************************************************
                       *********



ARM Macro Assembler    Page 5 Secure String I/O and Number Output


  167 00000000         ;Program
  168 00000000         ;Linker requires Reset_Handler
  169 00000000                 AREA             MyCode,CODE,READONLY
  170 00000000                 ENTRY
  171 00000000                 EXPORT           Reset_Handler
  172 00000000                 EXPORT           PutChar
  173 00000000                 IMPORT           LengthStringSB
  174 00000000                 IMPORT           Startup
  175 00000000         Reset_Handler
                               PROC             {},{}
  176 00000000         main
  177 00000000         ;-------------------------------------------------------
                       --------
  178 00000000         ;Mask interrupts
  179 00000000 B672            CPSID            I
  180 00000002         ;KL46 system startup with 48-MHz system clock
  181 00000002 F7FF FFFE       BL               Startup
  182 00000006         ;-------------------------------------------------------
                       --------
  183 00000006         ;>>>>> begin main program code <<<<<
  184 00000006 F000 F8B3       BL               Init_UART0_Polling 
                                                            ;initialize   
  185 0000000A         NEWSTRING
  186 0000000A 487D            LDR              R0,=Prompt  ;load promt address
                                                             into R0
  187 0000000C F7FF FFFE       BL               PutStringSB ;print the prompt
  188 00000010 487C            LDR              R0,=STRINGIN ;load input string
                                                             address into R0
  189 00000012 497D            LDR              R1,=MAX_STRING ;load max string
                                                             size into R1
  190 00000014 F000 F8A4       BL               NEWLINE     ;print a new line
  191 00000018 203E            MOVS             R0,#0x3E    ;load ">" into R0
  192 0000001A F7FF FFFE       BL               PutChar     ;print the ">"
  193 0000001E 4879            LDR              R0,=STRINGIN ;load input string
                                                             address into R0
  194 00000020 F7FF FFFE       BL               GetStringSB ;store input string
                                                            
  195 00000024 203C            MOVS             R0,#0x3C    ;load "<" into R0
  196 00000026 F7FF FFFE       BL               PutChar     ;print the "<"
  197 0000002A 4876            LDR              R0,=STRINGIN ;load input string
                                                             address into R0
  198 0000002C F7FF FFFE       BL               PutStringSB ;print the string
  199 00000030 203C            MOVS             R0,#0x3C    ;load "<" into R0
  200 00000032 F7FF FFFE       BL               PutChar     ;print the "<"
  201 00000036 F000 F893       BL               NEWLINE     ;print new line
  202 0000003A 4874            LDR              R0,=Length  ;load address of st
                                                            ring "Length:" into
                                                             R0
  203 0000003C F7FF FFFE       BL               PutStringSB ;print the "Length:
                                                            "
  204 00000040 4870            LDR              R0,=STRINGIN ;load input string
                                                             address into R0
  205 00000042 F7FF FFFE       BL               LengthStringSB ;find the length
                                                             of the string
  206 00000046 F7FF FFFE       BL               PutNumU     ;prints the string 
                                                            length
  207 0000004A F000 F889       BL               NEWLINE     ;print new line
  208 0000004E 486D            LDR              R0,=STRINGIN ;load input string
                                                             address into R0



ARM Macro Assembler    Page 6 Secure String I/O and Number Output


  209 00000050 2200            MOVS             R2,#0       ;clear R2
  210 00000052 7002            STRB             R2,[R0,#0]  ;clear bit 0 of R0
  211 00000054 E7D9            B                NEWSTRING   ;print new line
  212 00000056         ;>>>>>   end main program code <<<<<
  213 00000056         ;Stay here
  214 00000056                 ENDP
  215 00000056 E7FE            B                .
  216 00000058         ;>>>>> begin subroutine code <<<<<
  217 00000058         GetStringSB
                               PROC             {R0-R14},{}
  218 00000058         ;Read & store string from command line
  219 00000058         ;Calls: GetChar, PutChar
  220 00000058         ;Input: R0, R1 
  221 00000058         ;Output: Prints to command line
  222 00000058         ;Register Modifications:  
  223 00000058 B50F            PUSH             {R0,R1,R2,R3,LR} ;store registe
                                                            r vallues
  224 0000005A 1E49            SUBS             R1,R1,#1    ;R1 <- MAX_STRING -
                                                             1
  225 0000005C 2200            MOVS             R2,#0       ;clear R2   
  226 0000005E 0003            MOVS             R3,R0       ;store string point
                                                            er 
  227 00000060         GSLOOP
  228 00000060 F000 F8BC       BL               GetChar     ;store character fr
                                                            om string
  229 00000064 428A            CMP              R2,R1       ;is the string smal
                                                            ler than MAX_STRING
                                                            ?
  230 00000066 D208            BHS              OVRFLW      ;if yes, branch    
                                                             
  231 00000068 280D            CMP              R0,#0x0D
  232 0000006A D010            BEQ              GSQUIT      ;quit on carriage r
                                                            eturn
  233 0000006C 287F            CMP              R0,#0x7F
  234 0000006E D007            BEQ              ADDCHK      ;go back one on bac
                                                            kspace
  235 00000070 5498            STRB             R0,[R3,R2]  ;store char in M[R3
                                                            +R2]
  236 00000072 F7FF FFFE       BL               PutChar     ;print the characte
                                                            r         
  237 00000076 1C52            ADDS             R2,R2,#1    ;increment offset  
                                                                    
  238 00000078 E7F2            B                GSLOOP      ;go to start of loo
                                                            p
  239 0000007A         OVRFLW
  240 0000007A 280D            CMP              R0,#0x0D
  241 0000007C D007            BEQ              GSQUIT      ;quit on carriage r
                                                            eturn
  242 0000007E E7EF            B                GSLOOP      ;go to start of loo
                                                            p
  243 00000080         ADDCHK
  244 00000080 2A00            CMP              R2,#0
  245 00000082 D0ED            BEQ              GSLOOP      ;go to start of loo
                                                            p if backspaced on 
                                                            nothing
  246 00000084 1E52            SUBS             R2,R2,#1    ;else go back one b
                                                            yte
  247 00000086 207F            MOVS             R0,#0x7F    ;load backspace int
                                                            o R0



ARM Macro Assembler    Page 7 Secure String I/O and Number Output


  248 00000088 F7FF FFFE       BL               PutChar     ;send backspace to 
                                                            command line
  249 0000008C E7E8            B                GSLOOP      ;go to start of loo
                                                            p
  250 0000008E         GSQUIT
  251 0000008E 2000            MOVS             R0,#0       ;clear R0
  252 00000090 5498            STRB             R0,[R3,R2]  ;store 0 in M[R3+R2
                                                            ]
  253 00000092 200D            MOVS             R0,#0x0D    ;load carriage retu
                                                            rn into R0
  254 00000094 F7FF FFFE       BL               PutChar     ;print carriage ret
                                                            urn
  255 00000098 200A            MOVS             R0,#0x0A    ;load line feed int
                                                            o R0
  256 0000009A F7FF FFFE       BL               PutChar     ;print line feed
  257 0000009E BD0F            POP              {R0,R1,R2,R3,PC} ;restore regis
                                                            ter values
  258 000000A0         
  259 000000A0                 ENDP
  260 000000A0         
  261 000000A0         PutStringSB
                               PROC             {R0-R14},{}
  262 000000A0         ;Print string to command line
  263 000000A0         ;Calls: PutChar
  264 000000A0         ;Input: R0
  265 000000A0         ;Output: Print to command line
  266 000000A0         ;Register Modifications:  
  267 000000A0 B507            PUSH             {R0,R1,R2,LR} ;preserve registe
                                                            r values
  268 000000A2 2100            MOVS             R1,#0       ;clear R1
  269 000000A4 0002            MOVS             R2,R0       ;store string point
                                                            er in R2
  270 000000A6         PSLOOP
  271 000000A6 5C50            LDRB             R0,[R2,R1]  ;load character int
                                                            o R0
  272 000000A8 2800            CMP              R0,#0
  273 000000AA D003            BEQ              PSQUIT      ;quit on Null
  274 000000AC 1C49            ADDS             R1,R1,#1    ;increment offset
  275 000000AE F7FF FFFE       BL               PutChar     ;print the characte
                                                            r
  276 000000B2 E7F8            B                PSLOOP      ;go to start of loo
                                                            p
  277 000000B4         PSQUIT
  278 000000B4 BD07            POP              {R0,R1,R2,PC} ;restore register
                                                             values
  279 000000B6         
  280 000000B6                 ENDP
  281 000000B6         
  282 000000B6         PutNumU PROC             {R0-R14},{}
  283 000000B6         ;Prints decimal representation of the unsigned word valu
                       e in R0
  284 000000B6         ;Calls: DIVU, PutChar
  285 000000B6         ;Input: R0
  286 000000B6         ;Output: Print to command line
  287 000000B6         ;Register Modifications:
  288 000000B6 B507            PUSH             {R0,R1,R2,LR} ;preserve registe
                                                            r values
  289 000000B8 2800            CMP              R0,#0       ;if number is 0
  290 000000BA D024            BEQ              ISZERO      ;branch



ARM Macro Assembler    Page 8 Secure String I/O and Number Output


  291 000000BC 2200            MOVS             R2,#0       ;clear R2
  292 000000BE 0001            MOVS             R1,R0       ;set R1 to number 
  293 000000C0         
  294 000000C0 4857            LDR              R0,=DIV1M
  295 000000C2 F7FF FFFE       BL               DIVU        ;Number/1000000
  296 000000C6 F000 F841       BL               PRNTHLPR    ;print result
  297 000000CA 4856            LDR              R0,=DIV100K
  298 000000CC F7FF FFFE       BL               DIVU        ;Number/100000
  299 000000D0 F000 F83C       BL               PRNTHLPR    ;print result
  300 000000D4 4854            LDR              R0,=DIV10K
  301 000000D6 F7FF FFFE       BL               DIVU        ;Number/10000
  302 000000DA F000 F837       BL               PRNTHLPR    ;print result
  303 000000DE 4853            LDR              R0,=DIV1K
  304 000000E0 F7FF FFFE       BL               DIVU        ;Number/1000
  305 000000E4 F000 F832       BL               PRNTHLPR    ;print result
  306 000000E8 2064            MOVS             R0,#0x64
  307 000000EA F7FF FFFE       BL               DIVU        ;Number/100
  308 000000EE F000 F82D       BL               PRNTHLPR    ;print result
  309 000000F2 200A            MOVS             R0,#0xA
  310 000000F4 F7FF FFFE       BL               DIVU        ;Number/10
  311 000000F8 F000 F828       BL               PRNTHLPR    ;print result
  312 000000FC 0008            MOVS             R0,R1       ;load remainder int
                                                            o R0
  313 000000FE 3030            ADDS             R0,R0,#0x30 ;convert to ascii
  314 00000100 F7FF FFFE       BL               PutChar     ;print the number
  315 00000104 BD07            POP              {R0,R1,R2,PC} ;restore register
                                                             values
  316 00000106         ISZERO
  317 00000106 2030            MOVS             R0,#0x30
  318 00000108 F7FF FFFE       BL               PutChar     ;print "0"
  319 0000010C BD07            POP              {R0,R1,R2,PC} ;restore register
                                                             values
  320 0000010E         
  321 0000010E                 ENDP
  322 0000010E         
  323 0000010E         DIVU    PROC             {R2-R14},{}
  324 0000010E         ;Computes R1 / R0 into R0 remainder R1
  325 0000010E         ;Calls: DIVU, PutChar
  326 0000010E         ;Input: R0, R1
  327 0000010E         ;Output: R0, R1
  328 0000010E         ;Register Modifications: R0, R1
  329 0000010E B418            PUSH             {R3,R4}     ; store values of R
                                                            3 and R4
  330 00000110 2800            CMP              R0, #0      ;compare divisor to
                                                             0
  331 00000112 D002            BEQ              SET_CAR     ;if divisor is 0, g
                                                            o to special case
  332 00000114 2900            CMP              R1, #0      ;compare dividend t
                                                            o zero
  333 00000116 D00E            BEQ              ZERODIV     ;if dividend is 0, 
                                                            
  334 00000118 E007            B                BRK         ;go to special case
                                                            
  335 0000011A         SET_CAR
  336 0000011A F3EF 8300       MRS              R3,APSR     ;set C flag to 1
  337 0000011E 2420            MOVS             R4,#0x20
  338 00000120 0624            LSLS             R4,R4,#24
  339 00000122 4323            ORRS             R3,R3,R4
  340 00000124 F383 8800       MSR              APSR,R3



ARM Macro Assembler    Page 9 Secure String I/O and Number Output


  341 00000128 E00E            B                ENDDIV
  342 0000012A         BRK
  343 0000012A 2300            MOVS             R3, #0      ;put quotient in R3
                                                            
  344 0000012C         
  345 0000012C         DIVWHILE
  346 0000012C 4288            CMP              R0, R1      ;compare R0 and R1
  347 0000012E D803            BHI              ENDDIVWHILE ;if R0<R1 exit the 
                                                            loop
  348 00000130 1C5B            ADDS             R3, R3, #1  ;quotient ++
  349 00000132 1A09            SUBS             R1, R1, R0  ;R1 = R1 - R0
  350 00000134 E7FA            B                DIVWHILE
  351 00000136         
  352 00000136         ZERODIV
  353 00000136 2300            MOVS             R3,#0       ;IF dividend is zer
                                                            o, remainder is alw
                                                            ays zero
  354 00000138         ENDDIVWHILE
  355 00000138 0018            MOVS             R0, R3      ;R0 <- quotient, re
                                                            mainder = R1
  356 0000013A F3EF 8300       MRS              R3,APSR     ;clear C flag to 0
  357 0000013E 2420            MOVS             R4,#0x20
  358 00000140 0624            LSLS             R4,R4,#24
  359 00000142 43A3            BICS             R3,R3,R4
  360 00000144 F383 8800       MSR              APSR,R3
  361 00000148         
  362 00000148         ENDDIV
  363 00000148 BC18            POP              {R3,R4}     ;clear changes from
                                                             registers
  364 0000014A 4770            BX               LR          ;quit subroutine
  365 0000014C                 ENDP
  366 0000014C         
  367 0000014C         PRNTHLPR
  368 0000014C         ;Prints character if character is not a leading zero
  369 0000014C         ;Calls: PutChar
  370 0000014C         ;Input: R0, R2
  371 0000014C         ;Output: R0, R2
  372 0000014C         ;Register Modifications: R0, R2
  373 0000014C         
  374 0000014C B500            PUSH             {LR}        ;preserve register 
                                                            values
  375 0000014E 2A01            CMP              R2,#1       ;if character isnt 
                                                            a leading character
                                                            
  376 00000150 D001            BEQ              PRINTCHAR   ;print it
  377 00000152 2800            CMP              R0,#0       ;if character is le
                                                            ading zero
  378 00000154 D003            BEQ              PRNTQUIT    ;quit
  379 00000156         PRINTCHAR
  380 00000156 3030            ADDS             R0,R0,#0x30 ;convert char to as
                                                            cii
  381 00000158 F7FF FFFE       BL               PutChar     ;print character
  382 0000015C 2201            MOVS             R2,#1       ;indicates all futu
                                                            re numbers aren't l
                                                            eading
  383 0000015E         PRNTQUIT
  384 0000015E BD00            POP              {PC}        ;restore register v
                                                            alues
  385 00000160         



ARM Macro Assembler    Page 10 Secure String I/O and Number Output


  386 00000160         NEWLINE
  387 00000160         ;Prints a carriage return and a line feed
  388 00000160         ;Calls: PutChar
  389 00000160         ;Input:
  390 00000160         ;Output: Print to command line
  391 00000160         ;Register Modifications: 
  392 00000160 B501            PUSH             {R0,LR}     ;preserve register 
                                                            values
  393 00000162 200D            MOVS             R0,#0x0D    ;load carriage retu
                                                            rn into R0
  394 00000164 F7FF FFFE       BL               PutChar     ;print carriage ret
                                                            urn
  395 00000168 200A            MOVS             R0,#0x0A    ;load line feed int
                                                            o R0
  396 0000016A F7FF FFFE       BL               PutChar     ;print line feed
  397 0000016E BD01            POP              {R0,PC}     ;restore register v
                                                            alues
  398 00000170         
  399 00000170         Init_UART0_Polling
  400 00000170         ;Store initial values of R0, R1, and R2
  401 00000170 B407            PUSH             {R0,R1,R2}
  402 00000172         ;Select MCGPLLCLK / 2 as UART0 clock source
  403 00000172 482F            LDR              R0,=SIM_SOPT2
  404 00000174 492F            LDR              R1,=SIM_SOPT2_UART0SRC_MASK
  405 00000176 6802            LDR              R2,[R0,#0]
  406 00000178 438A            BICS             R2,R2,R1
  407 0000017A 492F            LDR              R1,=SIM_SOPT2_UART0_MCGPLLCLK_D
IV2
  408 0000017C 430A            ORRS             R2,R2,R1
  409 0000017E 6002            STR              R2,[R0,#0]
  410 00000180         ;Enable external connection for UART0
  411 00000180 482E            LDR              R0,=SIM_SOPT5
  412 00000182 492F            LDR              R1,= SIM_SOPT5_UART0_EXTERN_MAS
K_CLEAR
  413 00000184 6802            LDR              R2,[R0,#0]
  414 00000186 438A            BICS             R2,R2,R1
  415 00000188 6002            STR              R2,[R0,#0]
  416 0000018A         ;Enable clock for UART0 module
  417 0000018A 482E            LDR              R0,=SIM_SCGC4
  418 0000018C 492E            LDR              R1,= SIM_SCGC4_UART0_MASK
  419 0000018E 6802            LDR              R2,[R0,#0]
  420 00000190 430A            ORRS             R2,R2,R1
  421 00000192 6002            STR              R2,[R0,#0]
  422 00000194         ;Enable clock for Port A module
  423 00000194 482D            LDR              R0,=SIM_SCGC5
  424 00000196 492E            LDR              R1,= SIM_SCGC5_PORTA_MASK
  425 00000198 6802            LDR              R2,[R0,#0]
  426 0000019A 430A            ORRS             R2,R2,R1
  427 0000019C 6002            STR              R2,[R0,#0]
  428 0000019E         ;Connect PORT A Pin 1 (PTA1) to UART0 Rx (J1 Pin 02)
  429 0000019E 482D            LDR              R0,=PORTA_PCR1
  430 000001A0 492D            LDR              R1,=PORT_PCR_SET_PTA1_UART0_RX
  431 000001A2 6001            STR              R1,[R0,#0]
  432 000001A4         ;Connect PORT A Pin 2 (PTA2) to UART0 Tx (J1 Pin 04)
  433 000001A4 482D            LDR              R0,=PORTA_PCR2
  434 000001A6 492C            LDR              R1,=PORT_PCR_SET_PTA2_UART0_TX
  435 000001A8 6001            STR              R1,[R0,#0]
  436 000001AA         ;Disable UART0 receiver and transmitter
  437 000001AA 482D            LDR              R0,=UART0_BASE



ARM Macro Assembler    Page 11 Secure String I/O and Number Output


  438 000001AC 210C            MOVS             R1,#UART0_C2_T_R
  439 000001AE 78C2            LDRB             R2,[R0,#UART0_C2_OFFSET]
  440 000001B0 438A            BICS             R2,R2,R1
  441 000001B2 70C2            STRB             R2,[R0,#UART0_C2_OFFSET]
  442 000001B4         ;Set UART0 for 9600 baud, 8N1 protocol
  443 000001B4 2101            MOVS             R1,#UART0_BDH_9600
  444 000001B6 7001            STRB             R1,[R0,#UART0_BDH_OFFSET]
  445 000001B8 2138            MOVS             R1,#UART0_BDL_9600
  446 000001BA 7041            STRB             R1,[R0,#UART0_BDL_OFFSET]
  447 000001BC 2100            MOVS             R1,#UART0_C1_8N1
  448 000001BE 7081            STRB             R1,[R0,#UART0_C1_OFFSET]
  449 000001C0 2100            MOVS             R1,#UART0_C3_NO_TXINV
  450 000001C2 7181            STRB             R1,[R0,#UART0_C3_OFFSET]
  451 000001C4 210F            MOVS             R1,#UART0_C4_NO_MATCH_OSR_16
  452 000001C6 7281            STRB             R1,[R0,#UART0_C4_OFFSET]
  453 000001C8 2100            MOVS             R1,#UART0_C5_NO_DMA_SSR_SYNC
  454 000001CA 72C1            STRB             R1,[R0,#UART0_C5_OFFSET]
  455 000001CC 211F            MOVS             R1,#UART0_S1_CLEAR_FLAGS
  456 000001CE 7101            STRB             R1,[R0,#UART0_S1_OFFSET]
  458 000001D0 21C0            MOVS             R1,           #UART0_S2_NO_RXI
NV_BRK10_NO_LBKDETECT_CLEAR_FLAGS
  459 000001D2 7141            STRB             R1,[R0,#UART0_S2_OFFSET]
  460 000001D4         ;Enable UART0 receiver and transmitter
  461 000001D4 210C            MOVS             R1,#UART0_C2_T_R
  462 000001D6 70C1            STRB             R1,[R0,#UART0_C2_OFFSET]
  463 000001D8         ;Restore original register values
  464 000001D8 BC07            POP              {R0,R1,R2}
  465 000001DA 4770            BX               LR
  466 000001DC         
  467 000001DC         GetChar
  468 000001DC         ;Takes a character from input and stores it in R0
  469 000001DC         ;Inputs: R1, R2, R3
  470 000001DC         ;Outputs: R0
  471 000001DC         ;Register Modifications: R0, R1, R2, R3
  472 000001DC         ;Store initial values of R1, R1, and R2
  473 000001DC B40E            PUSH             {R1, R2, R3}
  474 000001DE         ;Poll RDRF until UART0 ready to receive 
  475 000001DE 4920            LDR              R1, =UART0_BASE
  476 000001E0 2220            MOVS             R2, #UART0_S1_RDRF_MASK
  477 000001E2         PollRx
  478 000001E2 790B            LDRB             R3, [R1, #UART0_S1_OFFSET]
  479 000001E4 4013            ANDS             R3, R3, R2
  480 000001E6 D0FC            BEQ              PollRx
  481 000001E8         ;Receive character and store in R0
  482 000001E8 79C8            LDRB             R0, [R1, #UART0_D_OFFSET]
  483 000001EA BC0E            POP              {R1, R2, R3}
  484 000001EC 4770            BX               LR          ; return to where t
                                                            he branch was calle
                                                            d from
  485 000001EE         PutChar
  486 000001EE         ;Transmits the character stored in R0
  487 000001EE         ;Inputs: R1, R2, R3
  488 000001EE         ;Outputs: R0
  489 000001EE         ;Register Modifications: R0, R1, R2, R3
  490 000001EE         ;Store initial values of R1, R2, and R3
  491 000001EE B40E            PUSH             {R1, R2, R3}
  492 000001F0         ;Poll TDRE Until UART0 is ready for transmit
  493 000001F0 491B            LDR              R1, =UART0_BASE
  494 000001F2 2280            MOVS             R2, #UART0_S1_TDRE_MASK



ARM Macro Assembler    Page 12 Secure String I/O and Number Output


  495 000001F4         
  496 000001F4         PollTx
  497 000001F4 790B            LDRB             R3, [R1, #UART0_S1_OFFSET]
  498 000001F6 4013            ANDS             R3, R3, R2
  499 000001F8 D0FC            BEQ              PollTx
  500 000001FA         ;Transmit Character Stored in R0
  501 000001FA 71C8            STRB             R0, [R1, #UART0_D_OFFSET]
  502 000001FC         ;Restore original register values
  503 000001FC BC0E            POP              {R1, R2, R3}
  504 000001FE 4770            BX               LR          ; return to where t
                                                            he branch was calle
                                                            d from
  505 00000200         
  506 00000200         ;>>>>>   end subroutine code <<<<<
  507 00000200                 ALIGN
  508 00000200         ;*******************************************************
                       *********
  509 00000200         ;Vector Table Mapped to Address 0 at Reset
  510 00000200         ;Linker requires __Vectors to be exported
  511 00000200 00000000 
              00000000 
              0000004F 
              00000000 
              00000000 
              00000000 
              00000000 
              00000000 
              000F4240 
              000186A0 
              00002710 
              000003E8 
              40048004 
              0C000000 
              04010000 
              40048010 
              00010007 
              40048034 
              00000400 
              40048038 
              00000200 
              40049004 
              01000200 
              40049008 
              4006A000         AREA             RESET, DATA, READONLY
  512 00000000                 EXPORT           __Vectors
  513 00000000                 EXPORT           __Vectors_End
  514 00000000                 EXPORT           __Vectors_Size
  515 00000000                 IMPORT           __initial_sp
  516 00000000                 IMPORT           Dummy_Handler
  517 00000000                 IMPORT           HardFault_Handler
  518 00000000         __Vectors
  519 00000000         ;ARM core vectors
  520 00000000 00000000        DCD              __initial_sp ;00:end of stack
  521 00000004 00000000        DCD              Reset_Handler ;01:reset vector
  522 00000008 00000000        DCD              Dummy_Handler ;02:NMI
  523 0000000C 00000000        DCD              HardFault_Handler 
                                                            ;03:hard fault
  524 00000010 00000000        DCD              Dummy_Handler ;04:(reserved)
  525 00000014 00000000        DCD              Dummy_Handler ;05:(reserved)



ARM Macro Assembler    Page 13 Secure String I/O and Number Output


  526 00000018 00000000        DCD              Dummy_Handler ;06:(reserved)
  527 0000001C 00000000        DCD              Dummy_Handler ;07:(reserved)
  528 00000020 00000000        DCD              Dummy_Handler ;08:(reserved)
  529 00000024 00000000        DCD              Dummy_Handler ;09:(reserved)
  530 00000028 00000000        DCD              Dummy_Handler ;10:(reserved)
  531 0000002C 00000000        DCD              Dummy_Handler ;11:SVCall (super
                                                            visor call)
  532 00000030 00000000        DCD              Dummy_Handler ;12:(reserved)
  533 00000034 00000000        DCD              Dummy_Handler ;13:(reserved)
  534 00000038 00000000        DCD              Dummy_Handler ;14:PendableSrvRe
                                                            q (pendable request
                                                             
  535 0000003C         ;   for system service)
  536 0000003C 00000000        DCD              Dummy_Handler ;15:SysTick (syst
                                                            em tick timer)
  537 00000040 00000000        DCD              Dummy_Handler ;16:DMA channel 0
                                                             xfer complete/erro
                                                            r
  538 00000044 00000000        DCD              Dummy_Handler ;17:DMA channel 1
                                                             xfer complete/erro
                                                            r
  539 00000048 00000000        DCD              Dummy_Handler ;18:DMA channel 2
                                                             xfer complete/erro
                                                            r
  540 0000004C 00000000        DCD              Dummy_Handler ;19:DMA channel 3
                                                             xfer complete/erro
                                                            r
  541 00000050 00000000        DCD              Dummy_Handler ;20:(reserved)
  542 00000054 00000000        DCD              Dummy_Handler ;21:command compl
                                                            ete; read collision
                                                            
  543 00000058 00000000        DCD              Dummy_Handler ;22:low-voltage d
                                                            etect;
  544 0000005C         ;   low-voltage warning
  545 0000005C 00000000        DCD              Dummy_Handler ;23:low leakage w
                                                            akeup
  546 00000060 00000000        DCD              Dummy_Handler ;24:I2C0
  547 00000064 00000000        DCD              Dummy_Handler ;25:I2C1
  548 00000068 00000000        DCD              Dummy_Handler ;26:SPI0 (all IRQ
                                                             sources)
  549 0000006C 00000000        DCD              Dummy_Handler ;27:SPI1 (all IRQ
                                                             sources)
  550 00000070 00000000        DCD              Dummy_Handler ;28:UART0 (status
                                                            ; error)
  551 00000074 00000000        DCD              Dummy_Handler ;29:UART1 (status
                                                            ; error)
  552 00000078 00000000        DCD              Dummy_Handler ;30:UART2 (status
                                                            ; error)
  553 0000007C 00000000        DCD              Dummy_Handler ;31:ADC0
  554 00000080 00000000        DCD              Dummy_Handler ;32:CMP0
  555 00000084 00000000        DCD              Dummy_Handler ;33:TPM0
  556 00000088 00000000        DCD              Dummy_Handler ;34:TPM1
  557 0000008C 00000000        DCD              Dummy_Handler ;35:TPM2
  558 00000090 00000000        DCD              Dummy_Handler ;36:RTC (alarm)
  559 00000094 00000000        DCD              Dummy_Handler ;37:RTC (seconds)
                                                            
  560 00000098 00000000        DCD              Dummy_Handler ;38:PIT (all IRQ 
                                                            sources)
  561 0000009C 00000000        DCD              Dummy_Handler ;39:I2S0



ARM Macro Assembler    Page 14 Secure String I/O and Number Output


  562 000000A0 00000000        DCD              Dummy_Handler ;40:USB0
  563 000000A4 00000000        DCD              Dummy_Handler ;41:DAC0
  564 000000A8 00000000        DCD              Dummy_Handler ;42:TSI0
  565 000000AC 00000000        DCD              Dummy_Handler ;43:MCG
  566 000000B0 00000000        DCD              Dummy_Handler ;44:LPTMR0
  567 000000B4 00000000        DCD              Dummy_Handler ;45:Segment LCD
  568 000000B8 00000000        DCD              Dummy_Handler ;46:PORTA pin det
                                                            ect
  569 000000BC 00000000        DCD              Dummy_Handler ;47:PORTC and POR
                                                            TD pin detect
  570 000000C0         __Vectors_End
  571 000000C0 000000C0 
                       __Vectors_Size
                               EQU              __Vectors_End - __Vectors
  572 000000C0                 ALIGN
  573 000000C0         ;*******************************************************
                       *********
  574 000000C0         ;Constants
  575 000000C0                 AREA             MyConst,DATA,READONLY
  576 00000000         ;>>>>> begin constants here <<<<<
  577 00000000         
  578 00000000 45 6E 74 
              65 72 20 
              61 20 73 
              74 72 69 
              6E 67 3A 
              00       Prompt  DCB              "Enter a string:", 0
  579 00000010 4C 65 6E 
              67 74 68 
              3A 00    Length  DCB              "Length:", 0
  580 00000018         
  581 00000018         ;>>>>>   end constants here <<<<<
  582 00000018                 ALIGN
  583 00000018         ;*******************************************************
                       *********
  584 00000018         ;Variables
  585 00000018                 AREA             MyData,DATA,READWRITE
  586 00000000         ;>>>>> begin variables here <<<<<
  587 00000000         
  588 00000000 00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 



ARM Macro Assembler    Page 15 Secure String I/O and Number Output


              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00 00 00 
              00       STRINGIN
                               SPACE            MAX_STRING
  589 0000004F         
  590 0000004F         ;>>>>>   end variables here <<<<<
  591 0000004F 00              ALIGN
  592 00000050                 END
Command Line: --debug --diag_suppress=9931 --cpu=Cortex-M0+ --apcs=interwork --
depend=.\objects\exercise06.d -o.\objects\exercise06.o -I.\RTE\_Target_1 -IC:\K
eil_v5\ARM\PACK\Keil\Kinetis_KLxx_DFP\1.13.0\Device\Include -IC:\Keil_v5\ARM\CM
SIS\Include --predefine="__EVAL SETA 1" --predefine="__UVISION_VERSION SETA 524
" --predefine="MKL46Z256xxx4 SETA 1" --list=.\listings\exercise06.lst exercise0
6.s
